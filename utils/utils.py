import collections
import json
import typing
from datetime import datetime

import django.db.utils
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.urls import reverse
from django.utils import timezone, translation
from django.utils.html import format_html

from backend.settings.environment import Environment


def translate_league_name(code, name):
    return settings.LEAGUES_CODES_MAP.get(code, name)


def load_json(path: str, catch_exception: bool = True) -> typing.Union[dict, Exception]:
    """
    Read json file with given abspath and return as dictionary.
    catch_exception=True will return exception if any appear,
    otherwise exception will be raised
    """
    try:
        with open(path, "r") as file:
            return json.loads(file.read())
    except Exception as e:
        if catch_exception:
            return e
        else:
            raise e


def is_allowed_interact_with_s38():
    return settings.CONFIGURATION is Environment.PRODUCTION and not settings.DEBUG


def get_current_season():
    """
    Return current season based on season stored in database
    """
    from clubs.models import Season  # avoid circular import

    if not settings.SCRAPPER:
        return "2021/2022"
    try:
        return Season.objects.get(is_current=True).name
    except ObjectDoesNotExist:
        return Season.define_current_season()
    except django.db.utils.ProgrammingError:
        return "2021/2022"


def calculate_prev_season(season: str):
    """2019/2020 ->   2018/2019"""
    assert isinstance(season, str), "season parameter is not an string"
    first, second = season.split("/")
    first_updated = int(first) - 1
    second_updated = int(second) - 1
    return f"{first_updated}/{second_updated}"


def linkify(field_name):
    """
    Converts a foreign key value into clickable links.

    If field_name is 'parent', link text will be str(obj.parent)
    Link will be admin url for the admin url for obj.parent.id:change
    """

    def _linkify(obj):
        linked_obj = getattr(obj, field_name)
        if linked_obj is None:
            return "-"

        app_label = linked_obj._meta.app_label
        model_name = linked_obj._meta.model_name
        view_name = f"admin:{app_label}_{model_name}_change"
        link_url = reverse(view_name, args=[linked_obj.pk])
        return format_html('<a href="{}">{}</a>', link_url, linked_obj)

    _linkify.short_description = field_name  # Sets column name
    return _linkify


def generate_map(filename):
    d = []
    import csv

    with open(filename, newline="") as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            d.append(dict(row))

    with open("league_filter_map.py", "w+") as filterfile:
        filterfile.write("# autogenerated\n")
        filterfile.write(f"LEAGUE_MAP = {d}")


def generate_teams_map(filename):
    d = []
    import csv

    with open(filename) as f:
        lines = f.readlines()
        out = {}
        for l in lines:
            data = l.strip().split(";;")
            if len(data) == 2:
                name = data[0].strip()
                team = data[1].strip()
                club = None
            elif len(data) == 3:
                name = data[0].strip()
                team = data[1].strip()
                club = data[2].strip()
            out[name] = {"name": team, "club": club}

    with open("teams_map.py", "w+") as filterfile:
        filterfile.write(f"TEAM_MAP = {out}")


def generate_league_options():
    from league_filter_map import LEAGUE_MAP

    out = ""
    lgs = []
    for item in LEAGUE_MAP:
        if item["seniority"] == "seniorskie":
            league_name = item.get("poziom_rozgrywkowy")
        else:
            league_name = item.get("rocznik")
        if league_name:
            name = league_name.split(" U")[0]
            lgs.append(name)
    for lgn in set(lgs):
        out += (
            '<option {% if "'
            + lgn
            + '" in request.GET|get_list:"league" %} selected="selected" {% endif %}>'
            + lgn
            + "</option>\n"
        )

    with open("filteroptions_league", "w+") as filterfile:
        filterfile.write(out)


def generate_vivo_options():
    from league_filter_map import LEAGUE_MAP

    out = ""
    lgs = []
    for item in LEAGUE_MAP:
        vivo_name = item.get("województwo")

        lgs.append(vivo_name)

    for lgn in set(lgs):
        out += (
            '<option {% if "'
            + lgn
            + '" in request.GET|get_list:"vivo" %} selected="selected" {% endif %}>'
            + lgn
            + "</option>\n"
        )

    with open("filteroptions_vivo", "w+") as filterfile:
        filterfile.write(out)


def update_dict_depth(d, u):
    """Update value of a nested dictionary of varying depth"""
    for k, v in u.items():
        if isinstance(v, collections.abc.Mapping):
            d[k] = update_dict_depth(d.get(k, {}), v)
        else:
            d[k] = v
    return d


def translate_to(langauge_code: str, text_input: str) -> str:
    """
    Select language by passing language_code and text to translate
    All language codes (ISO 639-1): https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    """
    translation.activate(langauge_code)
    return translation.gettext(text_input)


def calculate_age(birth_date: typing.Optional[datetime.date]) -> typing.Optional[int]:
    """
    Calculate the age based on the given birth date.
    """
    if birth_date:
        now = timezone.now()
        return (
            now.year
            - birth_date.year
            - ((now.month, now.day) < (birth_date.month, birth_date.day))
        )
    else:
        return None


def remove_polish_chars(filename: str) -> str:
    """Unify Polish chars to default"""
    trans_map: dict = str.maketrans("ŻŹĆŃĄŚŁĘÓżźćńąśłęó", "ZZCNASLEOzzcnasleo")
    return filename.translate(trans_map)


def validate_date_format(date_str: str, date_format: str = "%Y-%m-%d") -> None:
    """
    Validates if the given date string matches the specified format.
    Raises a ValueError if the format is invalid.
    """
    try:
        datetime.strptime(date_str, date_format)
    except ValueError:
        raise ValueError(f"Invalid date format: {date_str} does not match {date_format}")

