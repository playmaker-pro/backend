import collections
from django.utils.safestring import mark_safe
from django.urls import reverse
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from django.utils.html import format_html
from django.core.exceptions import ObjectDoesNotExist


def is_allowed_interact_with_s38():
    return settings.CONFIGURATION == "production" and not settings.DEBUG


def get_current_season():
    if not settings.SCRAPPER:
        return "2021/2022"
    from clubs.models import Season

    try:
        return Season.objects.get(is_current=True).name
    except ObjectDoesNotExist:
        return Season.define_current_season()


def calculate_prev_season(season: str):
    """2019/2020 ->   2018/2019"""
    assert isinstance(season, str), "season parameter is not an string"
    first, second = season.split("/")
    first_updated = int(first) - 1
    second_updated = int(second) - 1
    return f"{first_updated}/{second_updated}"


if settings.FORCED_SEASON_NAME:
    get_current_season_string = settings.FORCED_SEASON_NAME
else:
    get_current_season_string = get_current_season()

get_season_string = get_current_season()

get_prev_season_string = calculate_prev_season(get_season_string)


def linkify(field_name):
    """
    Converts a foreign key value into clickable links.

    If field_name is 'parent', link text will be str(obj.parent)
    Link will be admin url for the admin url for obj.parent.id:change
    """

    def _linkify(obj):
        linked_obj = getattr(obj, field_name)
        if linked_obj is None:
            return "-"

        app_label = linked_obj._meta.app_label
        model_name = linked_obj._meta.model_name
        view_name = f"admin:{app_label}_{model_name}_change"
        link_url = reverse(view_name, args=[linked_obj.pk])
        return format_html('<a href="{}">{}</a>', link_url, linked_obj)

    _linkify.short_description = field_name  # Sets column name
    return _linkify


def html_link_ref(field_name):
    """
    Make href out of field
    """

    def _make_ahref(obj):
        linked_obj = getattr(obj, field_name)
        if linked_obj is None:
            return "-"
        return format_html(
            '<a href="{}" target="_blank">{}</a>', linked_obj, linked_obj
        )

    _make_ahref.short_description = field_name
    return _make_ahref


def make_choices(choices):
    """
    Returns tuples of localized choices based on the dict choices parameter.
    Uses lazy translation for choices names.
    """
    return tuple([(k, _(v)) for k, v in choices])


def generate_map(filename):
    d = []
    import csv

    with open(filename, newline="") as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            d.append(dict(row))

    with open("league_filter_map.py", "w+") as filterfile:
        filterfile.write("# autogenerated\n")
        filterfile.write(f"LEAGUE_MAP = {d}")


def generate_teams_map(filename):
    d = []
    import csv

    with open(filename) as f:
        lines = f.readlines()
        out = {}
        for l in lines:
            data = l.strip().split(";;")
            if len(data) == 2:
                name = data[0].strip()
                team = data[1].strip()
                club = None
            elif len(data) == 3:
                name = data[0].strip()
                team = data[1].strip()
                club = data[2].strip()
            out[name] = {"name": team, "club": club}

    with open("teams_map.py", "w+") as filterfile:
        filterfile.write(f"TEAM_MAP = {out}")


def generate_league_options():

    from league_filter_map import LEAGUE_MAP

    out = ""
    lgs = []
    for item in LEAGUE_MAP:
        if item["seniority"] == "seniorskie":
            league_name = item.get("poziom_rozgrywkowy")
        else:
            league_name = item.get("rocznik")
        if league_name:
            name = league_name.split(" U")[0]
            lgs.append(name)
    for lgn in set(lgs):
        out += (
            '<option {% if "'
            + lgn
            + '" in request.GET|get_list:"league" %} selected="selected" {% endif %}>'
            + lgn
            + "</option>\n"
        )

    with open("filteroptions_league", "w+") as filterfile:
        filterfile.write(out)


def generate_vivo_options():

    from league_filter_map import LEAGUE_MAP

    out = ""
    lgs = []
    for item in LEAGUE_MAP:

        vivo_name = item.get("wojew√≥dztwo")

        lgs.append(vivo_name)

    for lgn in set(lgs):
        out += (
            '<option {% if "'
            + lgn
            + '" in request.GET|get_list:"vivo" %} selected="selected" {% endif %}>'
            + lgn
            + "</option>\n"
        )

    with open("filteroptions_vivo", "w+") as filterfile:
        filterfile.write(out)


def update_dict_depth(d, u):
    """Update value of a nested dictionary of varying depth"""
    for k, v in u.items():
        if isinstance(v, collections.abc.Mapping):
            d[k] = update_dict_depth(d.get(k, {}), v)
        else:
            d[k] = v
    return d
